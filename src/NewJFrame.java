
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author ayushgrg
 */
public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
        ft = new ArrayList<>();
        keys = new ArrayList<>();
        
        Enumeration e;
        try {
            e = NetworkInterface.getNetworkInterfaces();
            while(e.hasMoreElements())
            {
                NetworkInterface n = (NetworkInterface) e.nextElement();
                Enumeration ee = n.getInetAddresses();
                while (ee.hasMoreElements())
                {
                    InetAddress i = (InetAddress) ee.nextElement();
                    if(i instanceof Inet4Address){                      
                        System.out.println(i.getHostAddress());
                        ip.addItem(i.getHostAddress());  
                    }
                    
                   
                }
            }
        } catch (SocketException ex) {
            Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        ip = new javax.swing.JComboBox<>();
        jLabel3 = new javax.swing.JLabel();
        nport1 = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        nnumber1 = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        kip1 = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        kport1 = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        knumber1 = new javax.swing.JTextField();
        join1 = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        table1 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        keyarea = new javax.swing.JTextArea();
        jButton3 = new javax.swing.JButton();

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("chord");

        jLabel2.setText("IP Address");

        jLabel3.setText("Port");

        jLabel4.setText("Node Number");

        jLabel5.setText("Known IP Adrdess ");

        kip1.setText("127.0.0.1");

        jLabel6.setText("Known Port");

        jLabel7.setText("Known Node Number");

        join1.setText("JOIN");
        join1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                join1ActionPerformed(evt);
            }
        });

        jButton1.setText("PRINT");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        table1.setColumns(20);
        table1.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        table1.setRows(5);
        jScrollPane2.setViewportView(table1);

        keyarea.setColumns(20);
        keyarea.setRows(5);
        jScrollPane3.setViewportView(keyarea);

        jButton3.setText("DISCONNECT");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(43, 43, 43)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(61, 61, 61))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 894, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(join1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 135, Short.MAX_VALUE)
                                            .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                        .addGap(59, 59, 59)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(nport1, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(ip, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(nnumber1, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(kip1, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(kport1, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(knumber1, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 452, Short.MAX_VALUE)
                                    .addComponent(jScrollPane3))))
                        .addGap(0, 19, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(55, 55, 55)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(ip, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 45, Short.MAX_VALUE)
                            .addComponent(nport1))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 45, Short.MAX_VALUE)
                            .addComponent(nnumber1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(kip1, javax.swing.GroupLayout.DEFAULT_SIZE, 43, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(kport1, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(jScrollPane2))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 44, Short.MAX_VALUE)
                    .addComponent(knumber1)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(join1, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(40, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void join1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_join1ActionPerformed
        // join a node
    //    int i = (-10) % 8;
    //    System.out.println("i:      "+i);
        String nport2 = nport1.getText().toString();
        String nnumber2 = nnumber1.getText().toString();
        String knumber2 = knumber1.getText().toString();
        String kip2 = kip1.getText().toString();
        String kport2 = kport1.getText().toString();
        String nip2 = ip.getSelectedItem().toString();
        if(!(nport2.equals("")) && !(nnumber2.equals("")) && !(kport2.equals("")) && !(kip2.equals("")) && !(knumber2.equals(""))){
            nport = nport2;
            nnumber = Integer.parseInt(nnumber2);
            knumber = knumber2;
            kip = kip2;
            kport = kport2;
            nip = nip2;
            node = new Node(nnumber, nip, nport);
            acceptConn(Integer.parseInt(nport));
            
            if(knumber2.equals("-1")){
                successor = node;
                predecessor = null;
                int i=1;
                for( i=1;i<total_ft_entries;i++){
                    Node n = new Node(nnumber, nip, nport);
                    int str = (nnumber+(int)Math.pow(2, i-1))%total_nodes;
                    FingerTable fttemp = new FingerTable(str, str, (nnumber+(int)Math.pow(2, i)-1)%total_nodes, n);
                    ft.add(fttemp);
                    P("successfully joined");
                }
                Node n = new Node(nnumber, nip, nport);
                int str = (nnumber+(int)Math.pow(2, i-1))%total_nodes;
                FingerTable fttemp = new FingerTable(str, str, ((nnumber+7)%total_nodes), n);
                ft.add(fttemp);
                for(int i1=1;i1<30;i1++){
                    keys.add(i1);
                }
                showkeys();
                run_update_utilities();
            }
            else{
                predecessor = null;
                ask_k_tofind_successor(node, kip, kport);
                P("send request for successor");
                
                int i=1;
                for( i=1;i<total_ft_entries;i++){
                    int str = (nnumber+(int)Math.pow(2, i-1))%total_nodes;
                    FingerTable fttemp = new FingerTable(str, str, ((nnumber+(int)Math.pow(2, i)-1)%total_nodes), null);
                    ft.add(fttemp);
                    P("successfully joined");
                }
                int str = (nnumber+(int)Math.pow(2, i-1))%total_nodes;
                FingerTable fttemp = new FingerTable(str, str, ((nnumber+7)%total_nodes), null);
                ft.add(fttemp);
                printFingerTable();
                
//                successor = nnumber2;
//                predecessor = nnumber2;
//                for(int i=1;i<=total_ft_entries;i++){
//                    Node n = new Node(""+nnumber, nip, nport);
//                    int str = (nnumber+(int)Math.pow(2, i-1))%total_nodes;
//                    FingerTable fttemp = new FingerTable(str, str, (nnumber+(int)Math.pow(2, i))%total_nodes, n);
//                    ft.add(fttemp);
//                }
                
            }
        }
        
    }//GEN-LAST:event_join1ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // print finger table
        printFingerTable();
        
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // disconnect:
        System.err.print("Disconnect button started");
        try {
            disconnectnode();
        } catch (IOException ex) {
            Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }//GEN-LAST:event_jButton3ActionPerformed

    public void disconnectnode() throws IOException{
        t.cancel();
        if(!successor.equals(node)){
            if(successor!=null && (successor.num!=predecessor.num)){
                P("ist condition");
                String msg = "pls update prd";
                if(predecessor!=null){
                    msg = msg + ":"+predecessor.num+":"+predecessor.ndip+":"+predecessor.ndport;
                }else{
                    msg = msg + ":null";
                }
                for(int i=0;i<keys.size();i++){
                    msg = msg + ":" + keys.get(i);
                }
                sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
                if(predecessor!=null){
                    String msg1 = "pls update suc:"+successor.num+":"+successor.ndip+":"+successor.ndport;
                    sendMessage(predecessor.ndip, Integer.parseInt(predecessor.ndport), msg1);
                }

            }
            else if(successor.num==predecessor.num){
                P("ii condition");
                String msg1 = "pls update suc and put pred null:"+predecessor.num+":"+predecessor.ndip+":"+predecessor.ndport;
                for(int i=0;i<keys.size();i++){
                    msg1 = msg1 + ":" + keys.get(i);
                }
                    sendMessage(predecessor.ndip, Integer.parseInt(predecessor.ndport), msg1);
            }
        }
        else{
            P("iii condition");
            System.exit(0);
        }
        socket.close();
        thread.stop();
        System.exit(0);
    }
    
    
    public void printFingerTable(){
        table1.append("-----------------------------------------------------\n");
        if(successor!=null){
            String msg = "Successor:"+successor.num;
            table1.append(msg+"\n");
            System.err.println("Successor:"+successor.num);
        }
        else{
            String msg = "Successor:"+successor;
            table1.append(msg+"\n");
            System.err.println("successor:"+successor);
        }
        if(predecessor!=null){
            String msg = "predecessor:"+predecessor.num;
            table1.append(msg+"\n");
            System.err.println("predecessor:"+predecessor.num);
        }
        else{
            String msg = "predecessor:"+predecessor;
            table1.append(msg+"\n");
            System.err.println("predecessor:"+predecessor);
        }
        for(FingerTable fg : ft){
            String msg = ""+fg.toString();
            table1.append(msg+"\n");
            System.err.println(""+fg.toString());
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    
    void find_successor(int id, int index, String nodeIp, int nodeport){
        P("in find successor");
        find_predecessor(id,index, nodeIp, nodeport);
        // when answer will be received send the answer
    }
    
    Node closest_preceding_finger(int id){
        P("in Closest Preecding finger");
        int min  = 9999999;
        int max = -1;
        Node ndd = null;
        Node ndd2 = null;
//        printFingerTable();
        for(int i = total_ft_entries; i>=1;i--){
           
            FingerTable ftt = ft.get(i-1);
//            if(ftt.snode!=null && belongsto(nnumber, id, ftt.snode.num)){
//                return ftt.snode;
//            }
            if(ftt.snode!=null && ftt.snode.num<=id && id-ftt.snode.num<min){
                min = id - ftt.snode.num;
                ndd = ftt.snode;
            }
            else if(ftt.snode!=null && ftt.snode.num>id && ftt.snode.num-id>max){
                max = ftt.snode.num - id;
                ndd2 = ftt.snode;
            }
            
            
            
//            P("Interval :" +ftr.node.nodeId  +" --- "+this.nodeId  + "  &&& " + id);
//            if((ftr.node.nodeId >  this.nodeId && ftr.node.nodeId < id) || (interval_test(this.nodeId, id, ftr.node.nodeId))){
//                P("found");
//                return ftr.node;
//            }
        }
        if(ndd!=null && ndd2!=null)
            P("min max nddnum ndd2num"+min +"   "+max+"    as   "+ndd.num+"        "+ndd2.num);
        if(min!=9999999){
                return ndd;
            }
        else if(max!=-1){
                return ndd2;
        }
        return node;
//        P("ZReturning myself");
//        return this;
    }
    
    void find_predecessor(int id,int queryingFingerIndex, String nodeIp, int nodeport){
        Node newnode = node;
        Node newnodesuccessor = successor;
        if(newnode.num==id){
            P("come btw node and its successor:"+newnode.num+" vfdf  "+newnode.num+"    "+id);
            if(!(nodeIp.equals(nip) && nodeport==Integer.parseInt(nport))){
                String msg = "UpdateFingerTable:"+queryingFingerIndex+":"+newnode.num+":"+newnode.ndip+":"+newnode.ndport;
                P(msg);
                sendMessage(nodeIp, nodeport, msg);
            }
            else{
                updateFingerTable(queryingFingerIndex, newnode);
            }
        }
        else if(belongsto(newnode.num, newnodesuccessor.num, id)){
            P("come btw node and its successor:"+newnode.num+" vfdf  "+newnodesuccessor.num+"    "+id);
            if(!(nodeIp.equals(nip) && nodeport==Integer.parseInt(nport))){
                String msg = "UpdateFingerTable:"+queryingFingerIndex+":"+newnodesuccessor.num+":"+newnodesuccessor.ndip+":"+newnodesuccessor.ndport;
                P(msg);
                sendMessage(nodeIp, nodeport, msg);
            }
            else{
                updateFingerTable(queryingFingerIndex, newnodesuccessor);
            }
        }
        else{
            newnode  = closest_preceding_finger(id);
            P(""+newnode.num);
      //  while(id < n_new.nodeId && id >= n_new.fingerTable.get(0).node.nodeId){
      //        this node all details for further evaluation
      //        n_new  = n_new.closest_preceding_finger(id);     
      //  }
      // above equivalent code
      // query node n_new  finger table
      // send message *************************88888
     
            if(newnode!=null && newnode!=node){
                String msg = "sendforfindpredecessor:"+id+":"+queryingFingerIndex+":"+nodeIp+":"+nodeport;
                sendMessage(newnode.ndip, Integer.parseInt(newnode.ndport), msg);
            }
        }
    }
    
    
    void updateFingerTable(int queryingFingerIndex, Node nd){
        ft.get(queryingFingerIndex).updateNode(nd);
    }
    
    
    
    boolean belongsto(int n, int scr, int id){
        if((n<scr) && (id>=n && id<=scr)){
            P(n+"   "+scr+"     "+id);
            P("11");
            return true;
        }
        else if((n>=scr) && ((id>=n && id<total_nodes) || (id>=0 && id<=scr))){
            P(n+"   "+scr+"     "+id);
            P("22");
            return true;
        }
        return false;
    }
    
    
    void P(String str){
        System.out.println(""+str);
    }
    
    
    // concurrent join
    void ask_k_tofind_successor(Node n, String nodeip, String nodeport){
        String msg = "findsuccessor:"+n.num+":"+n.ndip+":"+n.ndport;
        sendMessage(nodeip, Integer.parseInt(nodeport), msg);
    }
    
    
    //notify
    void notifysuccessor(){
        if(successor!= null){
            P(nnumber+"may be your predeccor");
            String msg = "i may pred:"+node.num+":"+node.ndip+":"+node.ndport;
            if(!(successor.ndip.equals(nip) && successor.ndport.equals(nport)))
                sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
        }
    }
    
    //stablise
    void ask_successor_itspredecessor(){
        P(""+nnumber+"asking successor its predecor");
        String msg = "tell your pred:"+node.ndip+":"+node.ndport;
        if(successor!=null && !(successor.ndip.equals(nip) && successor.ndport.equals(nport)))
            sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
        else{
            if((predecessor!=null) && predecessor.num!=nnumber && belongsto(nnumber, successor.num, predecessor.num)){
                successor = new Node(predecessor.num, predecessor.ndip, predecessor.ndport);
            }
            if(successor!=null){
                notifysuccessor();
            }
        }
            
    }
    
    
    //fix fingers
    void fixfinger(){
        P("fixfinger    "+index);
        if(successor != null )
        for(int i = 0;i<total_ft_entries;i++){
            find_successor(ft.get(i).start, i, nip, Integer.parseInt(nport));
        }
    }
    
    
    void updatekeys(){
        if(successor!=null && predecessor!= null && successor!=node){
            String msg = "transferkeys:"+node.num+":"+node.ndip+":"+node.ndport+":"+predecessor.num+":"+predecessor.ndip+":"+predecessor.ndport;
            sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
        }
//        if(successor!=null && successor!=node){
//            String msg = "transferkeys:"+node.num+":"+node.ndip+":"+node.ndport+":"+predecessor.num+":"+predecessor.ndip+":"+predecessor.ndport;
//            sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
//        }
    }
    
    void showkeys(){
        keyarea.setText("");
        if(keys.isEmpty()){
            keyarea.setText("No keys are in this node");
        }
        else{
            for(int i=0;i<keys.size();i++){
                keyarea.append(keys.get(i)+"    ");
            }
        }
    }
    
    
    
    
    
    
    void acceptConn(int listen){
        try {
            socket = new ServerSocket(listen);

            Runnable r = new Runnable() {
                @Override
                public void run() {
                    DataInputStream din = null;
                    while(true){
                        try {
                            System.out.println("trying accepting");
                            Socket s = socket.accept();
                            din = new DataInputStream(s.getInputStream());
                            String msg = din.readUTF();
                            System.out.println("Mesage Received "+ msg);
                            // hadle message
                            handler(msg);
                            System.out.println("Processing of mesage completed "+ msg);
                            s.close(); 
                        }
                        catch (IOException ex) {
                            P("message is not receiving");
                            Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                }
            };
            thread = new Thread(r);
            thread.start();
        } catch (IOException ex) {
            
        }   
    }
    
    
    void run_update_utilities(){
//        Runnable r = new Runnable() {
//    //        TimerTask task = new TimerTask() {
//            @Override
//            public void run() {
//                while(true){
//                    P("thread is running");
//                    notifysuccessor();
//                    ask_successor_itspredecessor();
//                    fixfinger();
//                   //   stablize();
//                   // fix_fingers();
//                }
//            }
//            
//        };
//        Thread t = new Thread(r);
//        t.start();
     //   Timer timer = new Timer();
     //   timer.schedule(task, 1000l, 3000l); 
        
            t = new Timer();
          int seconds = 5;
          TimerTask task= new TimerTask() {
                @Override
                public void run() {
                    notifysuccessor();
                    ask_successor_itspredecessor();
                    updatekeys();
                    fixfinger();
                   
                    showkeys();
                    P("calling my methods");
                    P("call ended my methods");
              }
          };
          t.scheduleAtFixedRate(task,0, seconds*1000);
          
     
     System.out.println("Update utilities started");
        
        
        
    }
    
    
    void handler(String msges){
        String[] msg = msges.split(":");
        if(msg[0].equals("UpdateFingerTable")){
            P("handler finger table is updating");
            Node nd = new Node(Integer.parseInt(msg[2]), msg[3], msg[4]);
            if(Integer.parseInt(msg[1])==-1){
                P("successor is updating");
                successor = nd;
                updatekeys();
                showkeys();
                run_update_utilities();
//                notifysuccessor();
            }
            else{
                updateFingerTable(Integer.parseInt(msg[1]), nd);
            }
        }
        else if(msg[0].equals("sendforfindpredecessor")){
            if(successor != null)
            find_successor(Integer.parseInt(msg[1]), Integer.parseInt(msg[2]), msg[3], Integer.parseInt(msg[4]));
        }
        else if(msg[0].equals("findsuccessor")){
            P("message is handling");
            if(successor != null)
            find_successor(Integer.parseInt(msg[1]), -1, msg[2], Integer.parseInt(msg[3]));
        }
        else if(msg[0].equals("i may pred")){
            P(""+msg[1]+"notifies");
            if(predecessor==null || (belongsto(predecessor.num, nnumber, Integer.parseInt(msg[1])))){
                if(nnumber!=Integer.parseInt(msg[1])){
                    P("Predecessor updated successfuly");
                    predecessor = new Node(Integer.parseInt(msg[1]), msg[2], msg[3]);
                }
            }
            
        }
        else if(msg[0].equals("tell your pred")){
            String msg1 = "my pred is:";
            if(predecessor==null){
                msg1 += "null";
            }
            else{
                msg1 = msg1+ predecessor.num + ":"+predecessor.ndip + ":" + predecessor.ndport;  
            }
            sendMessage(msg[1], Integer.parseInt(msg[2]), msg1);
        }
        else if(msg[0].equals("my pred is")){
            if((!msg[1].equals("null")) && Integer.parseInt(msg[1])!=nnumber && belongsto(nnumber, successor.num, Integer.parseInt(msg[1]))){
                successor = new Node(Integer.parseInt(msg[1]), msg[2], msg[3]);
                updatekeys();
                showkeys();
            }
            if(successor!=null){
                notifysuccessor();
            }
        }
        else if(msg[0].equals("transferkeys")){
            if(!keys.isEmpty()){
                String msg1 = "yourkeysare";
                    if(((Integer.parseInt(msg[4])+1)%total_nodes)==Integer.parseInt(msg[1])){
                        for(int i=0;i<keys.size();i++){
                            int temp = keys.get(i)%total_nodes;
                            if(((Integer.parseInt(msg[4])+1)%total_nodes)==temp && temp!=node.num){
                                msg1 = msg1 + ":" + keys.get(i);
                                keys.remove((Integer)keys.get(i));
                                i--;
                        }
                    }
                    P("msg send"+msg1);
                    sendMessage(msg[2], Integer.parseInt(msg[3]), msg1);
                }
                else{
                    for(int i=0;i<keys.size();i++){
                    int temp = keys.get(i)%total_nodes;
                    if(belongsto((Integer.parseInt(msg[4])+1)%total_nodes, Integer.parseInt(msg[1]), temp)){
                        P("keychecking   "+keys.get(i));
                        msg1 = msg1 + ":" + keys.get(i);
                        keys.remove((Integer)keys.get(i));
                        i--;
                    }
                }
                P("msg send"+msg1);
                sendMessage(msg[2], Integer.parseInt(msg[3]), msg1);
                }
                
            }
        }
        else if(msg[0].equals("yourkeysare")){
            P("msg rcvd"+msg);
            for(int i=1;i<msg.length;i++){
                keys.add(Integer.parseInt(msg[i]));
                
            }
        }
        else if(msg[0].equals("pls update prd")){
            P("msg rcvd"+msg);
            if(!msg[1].equals("null")){
                Node tmp = new Node(Integer.parseInt(msg[1]), msg[2], msg[3]);
                
                predecessor = tmp;
                if(msg.length>4){
                    for(int i=4;i<msg.length;i++){
                        keys.add(Integer.parseInt(msg[i]));
                    }
                }
            }
            else{
                predecessor = null;
                if(msg.length>2){
                    for(int i=2;i<msg.length;i++){
                        keys.add(Integer.parseInt(msg[i]));
                    }
                }
            }
        }
        else if(msg[0].equals("pls update suc")){
            Node tmp = new Node(Integer.parseInt(msg[1]), msg[2], msg[3]);
            successor = tmp;
        }
        else if(msg[0].equals("pls update suc and put pred null")){
            Node tmp = new Node(Integer.parseInt(msg[1]), msg[2], msg[3]);
                successor = tmp;
                predecessor = null;
                if(msg.length>4){
                    for(int i=4;i<msg.length;i++){
                        keys.add(Integer.parseInt(msg[i]));
                    }
                }
        }
    }
    
    
    
    void sendMessage(String ip, int port, String msg){
//        if(!(ip.equals(nip) && port==Integer.parseInt(nport))){
            try {
                 System.out.println("Message Sending " + msg);
                P("trying on ip and port: "+ip+"     "+port);
                 Socket s = new Socket(ip,port);
                
                DataOutputStream dout = new DataOutputStream(s.getOutputStream());
                dout.writeUTF(msg);
                s.close();
                System.out.println("Message Sent " + msg);
            } catch (IOException ex) {
                P("some node has failed in the ring");
                if((msg.split(":")[0]).equals("sendforfindpredecessor")){
                    sendMessage(successor.ndip, Integer.parseInt(successor.ndport), msg);
                }
                Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
            }  
//        }
//        else{
//            P("message failed sending: "+ip+"   "+nip+"     "+port+"       "+nport);
//        }
    }
    
    
    
    
    
    
    Timer t;
    int index = 0;
    String nip = "";
    String nport = "";
    int nnumber;
    String kport = "";
    String knumber = "";
    String kip = "";
    ArrayList<FingerTable> ft;
    int total_nodes = 8;
    int total_ft_entries = 3;
    Node successor;
    Node predecessor;
    ArrayList<Integer> keys;
    Node node;
    ServerSocket socket;
    Thread thread;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> ip;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable jTable1;
    private javax.swing.JButton join1;
    private javax.swing.JTextArea keyarea;
    private javax.swing.JTextField kip1;
    private javax.swing.JTextField knumber1;
    private javax.swing.JTextField kport1;
    private javax.swing.JTextField nnumber1;
    private javax.swing.JTextField nport1;
    private javax.swing.JTextArea table1;
    // End of variables declaration//GEN-END:variables
}


class FingerTable{
    int start;
    int stInt;
    int endInt;
    Node snode;
    

    
    FingerTable(int st, int strt, int end, Node node) {
        start = st;
        stInt = strt;
        endInt = end;
        snode = node;
    }

    void updateNode(Node node) {
        snode = node;
    }

    @Override
    public String toString() {
        if(snode!=null)
            return start + "---"+stInt + "-"+endInt+"---"+ snode.num;
        else
            return start + "---"+stInt + "-"+endInt+"---"+ snode;
    }
}

class Node{
    int num;
    String ndip;
    String ndport;
    
    Node(int n, String ip, String port){
        num = n;
        ndip = ip;
        ndport = port;
    }
    
    
}
